"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectCriteriaNode = void 0;
const core_1 = require("@mikro-orm/core");
const internal_1 = require("./internal");
class ObjectCriteriaNode extends internal_1.CriteriaNode {
    static create(metadata, entityName, payload, parent, key) {
        const node = new ObjectCriteriaNode(metadata, entityName, parent, key);
        const meta = metadata.get(entityName, false, false);
        node.payload = Object.keys(payload).reduce((o, item) => {
            const prop = meta === null || meta === void 0 ? void 0 : meta.properties[item];
            if ((prop === null || prop === void 0 ? void 0 : prop.reference) === core_1.ReferenceType.EMBEDDED) {
                const operator = Object.keys(payload[item]).some(f => core_1.Utils.isOperator(f));
                if (operator) {
                    throw core_1.ValidationError.cannotUseOperatorsInsideEmbeddables(entityName, prop.name, payload);
                }
                const map = Object.keys(payload[item]).reduce((oo, k) => {
                    oo[prop.embeddedProps[k].name] = payload[item][k];
                    return oo;
                }, {});
                o[item] = internal_1.CriteriaNode.create(metadata, entityName, map, node, item);
            }
            else {
                const childEntity = prop && prop.reference !== core_1.ReferenceType.SCALAR ? prop.type : entityName;
                o[item] = internal_1.CriteriaNode.create(metadata, childEntity, payload[item], node, item);
            }
            return o;
        }, {});
        return node;
    }
    process(qb, alias) {
        const nestedAlias = qb.getAliasForEntity(this.entityName, this);
        const ownerAlias = alias || qb.alias;
        if (nestedAlias) {
            alias = nestedAlias;
        }
        if (this.shouldAutoJoin(nestedAlias)) {
            alias = this.autoJoin(qb, ownerAlias);
        }
        return Object.keys(this.payload).reduce((o, field) => {
            const childNode = this.payload[field];
            const payload = childNode.process(qb, this.prop ? alias : ownerAlias);
            const operator = core_1.Utils.isOperator(field);
            const customExpression = internal_1.QueryBuilderHelper.isCustomExpression(field);
            if (childNode.shouldInline(payload)) {
                Object.assign(o, payload);
            }
            else if (childNode.shouldRename(payload)) {
                o[childNode.renameFieldToPK(qb)] = payload;
            }
            else if (operator || customExpression || field.includes('.') || ![internal_1.QueryType.SELECT, internal_1.QueryType.COUNT].includes(qb.type)) {
                o[field] = payload;
            }
            else {
                o[`${alias}.${field}`] = payload;
            }
            return o;
        }, {});
    }
    willAutoJoin(qb, alias) {
        const nestedAlias = qb.getAliasForEntity(this.entityName, this);
        const ownerAlias = alias || qb.alias;
        if (nestedAlias) {
            alias = nestedAlias;
        }
        if (this.shouldAutoJoin(nestedAlias)) {
            return true;
        }
        return Object.keys(this.payload).some(field => {
            const childNode = this.payload[field];
            return childNode.willAutoJoin(qb, this.prop ? alias : ownerAlias);
        });
    }
    shouldInline(payload) {
        const customExpression = internal_1.QueryBuilderHelper.isCustomExpression(this.key);
        const scalar = core_1.Utils.isPrimaryKey(payload) || payload instanceof RegExp || payload instanceof Date || customExpression;
        const operator = core_1.Utils.isObject(payload) && Object.keys(payload).every(k => core_1.Utils.isOperator(k, false));
        return !!this.prop && this.prop.reference !== core_1.ReferenceType.SCALAR && !scalar && !operator;
    }
    shouldAutoJoin(nestedAlias) {
        if (!this.prop || !this.parent) {
            return false;
        }
        const embeddable = this.prop.reference === core_1.ReferenceType.EMBEDDED;
        const knownKey = [core_1.ReferenceType.SCALAR, core_1.ReferenceType.MANY_TO_ONE, core_1.ReferenceType.EMBEDDED].includes(this.prop.reference) || (this.prop.reference === core_1.ReferenceType.ONE_TO_ONE && this.prop.owner);
        const composite = this.prop.joinColumns && this.prop.joinColumns.length > 1;
        const operatorKeys = knownKey && Object.keys(this.payload).every(key => core_1.Utils.isOperator(key, false));
        return !nestedAlias && !operatorKeys && !composite && !embeddable;
    }
    autoJoin(qb, alias) {
        const nestedAlias = qb.getNextAlias();
        const customExpression = internal_1.QueryBuilderHelper.isCustomExpression(this.key);
        const scalar = core_1.Utils.isPrimaryKey(this.payload) || this.payload instanceof RegExp || this.payload instanceof Date || customExpression;
        const operator = core_1.Utils.isObject(this.payload) && Object.keys(this.payload).every(k => core_1.Utils.isOperator(k, false));
        const field = `${alias}.${this.prop.name}`;
        if (this.prop.reference === core_1.ReferenceType.MANY_TO_MANY && (scalar || operator)) {
            qb.join(field, nestedAlias, undefined, 'pivotJoin', this.getPath());
        }
        else {
            const prev = qb._fields.slice();
            qb.join(field, nestedAlias, undefined, 'leftJoin', this.getPath());
            qb._fields = prev;
        }
        return nestedAlias;
    }
}
exports.ObjectCriteriaNode = ObjectCriteriaNode;
//# sourceMappingURL=ObjectCriteriaNode.js.map