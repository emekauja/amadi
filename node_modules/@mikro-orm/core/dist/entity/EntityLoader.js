"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityLoader = void 0;
const enums_1 = require("./enums");
const utils_1 = require("../utils");
const Collection_1 = require("./Collection");
const enums_2 = require("../enums");
const Reference_1 = require("./Reference");
const wrap_1 = require("./wrap");
class EntityLoader {
    constructor(em) {
        this.em = em;
        this.metadata = this.em.getMetadata();
        this.driver = this.em.getDriver();
    }
    async populate(entityName, entities, populate, where = {}, orderBy = {}, refresh = false, validate = true, lookup = true) {
        if (entities.length === 0 || populate === false) {
            return;
        }
        populate = this.normalizePopulate(entityName, populate, lookup);
        const invalid = populate.find(({ field }) => !this.em.canPopulate(entityName, field));
        if (validate && invalid) {
            throw utils_1.ValidationError.invalidPropertyName(entityName, invalid.field);
        }
        for (const pop of populate) {
            await this.populateField(entityName, entities, pop, where, orderBy, refresh);
        }
    }
    normalizePopulate(entityName, populate, lookup) {
        if (populate === true || populate.some(p => p.all)) {
            populate = this.lookupAllRelationships(entityName);
        }
        else {
            populate = utils_1.Utils.asArray(populate);
        }
        if (lookup) {
            populate = this.lookupEagerLoadedRelationships(entityName, populate);
        }
        populate.forEach(p => {
            if (!p.field.includes('.')) {
                return;
            }
            const [f, ...parts] = p.field.split('.');
            p.field = f;
            p.children = p.children || [];
            const prop = this.metadata.get(entityName).properties[f];
            p.children.push(this.expandNestedPopulate(prop.type, parts));
        });
        return populate;
    }
    /**
     * Expands `books.perex` like populate to use `children` array instead of the dot syntax
     */
    expandNestedPopulate(entityName, parts) {
        const meta = this.metadata.get(entityName);
        const field = parts.shift();
        const prop = meta.properties[field];
        const ret = { field };
        if (parts.length > 0) {
            ret.children = [this.expandNestedPopulate(prop.type, parts)];
        }
        return ret;
    }
    /**
     * preload everything in one call (this will update already existing references in IM)
     */
    async populateMany(entityName, entities, populate, where, orderBy, refresh) {
        const field = populate.field;
        const prop = this.metadata.get(entityName).properties[field];
        if (prop.reference === enums_1.ReferenceType.SCALAR && prop.lazy) {
            return [];
        }
        // set populate flag
        entities.forEach(entity => {
            if (utils_1.Utils.isEntity(entity[field], true) || entity[field] instanceof Collection_1.Collection) {
                wrap_1.wrap(entity[field], true).populated();
            }
        });
        const filtered = this.filterCollections(entities, field, refresh);
        const innerOrderBy = utils_1.Utils.isObject(orderBy[prop.name]) ? orderBy[prop.name] : undefined;
        if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && this.driver.getPlatform().usesPivotTable()) {
            return this.findChildrenFromPivotTable(filtered, prop, field, refresh, where[prop.name], innerOrderBy);
        }
        const subCond = utils_1.Utils.isPlainObject(where[prop.name]) ? where[prop.name] : {};
        const data = await this.findChildren(entities, prop, refresh, subCond, populate, innerOrderBy);
        this.initializeCollections(filtered, prop, field, data);
        return data;
    }
    initializeCollections(filtered, prop, field, children) {
        if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            this.initializeOneToMany(filtered, children, prop, field);
        }
        if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && !prop.owner && !this.driver.getPlatform().usesPivotTable()) {
            this.initializeManyToMany(filtered, children, prop, field);
        }
    }
    initializeOneToMany(filtered, children, prop, field) {
        for (const entity of filtered) {
            const items = children.filter(child => utils_1.Utils.unwrapReference(child[prop.mappedBy]) === entity);
            entity[field].hydrate(items);
        }
    }
    initializeManyToMany(filtered, children, prop, field) {
        for (const entity of filtered) {
            const items = children.filter(child => child[prop.mappedBy].contains(entity));
            entity[field].hydrate(items);
        }
    }
    async findChildren(entities, prop, refresh, where, populate, orderBy) {
        const children = this.getChildReferences(entities, prop, refresh);
        const meta = this.metadata.get(prop.type);
        let fk = utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys);
        if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY || (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && !prop.owner)) {
            fk = meta.properties[prop.mappedBy].name;
        }
        if (prop.reference === enums_1.ReferenceType.ONE_TO_ONE && !prop.owner && !this.em.config.get('autoJoinOneToOneOwner')) {
            children.length = 0;
            children.push(...entities);
            fk = meta.properties[prop.mappedBy].name;
        }
        if (children.length === 0) {
            return [];
        }
        const ids = utils_1.Utils.unique(children.map(e => utils_1.Utils.getPrimaryKeyValues(e, wrap_1.wrap(e, true).__meta.primaryKeys, true)));
        where = Object.assign({ [fk]: { $in: ids } }, where);
        orderBy = orderBy || prop.orderBy || { [fk]: enums_2.QueryOrder.ASC };
        return this.em.find(prop.type, where, { orderBy, refresh, populate: populate.children });
    }
    async populateField(entityName, entities, populate, where, orderBy, refresh) {
        if (!populate.children) {
            return void await this.populateMany(entityName, entities, populate, where, orderBy, refresh);
        }
        await this.populateMany(entityName, entities, populate, where, orderBy, refresh);
        const children = [];
        for (const entity of entities) {
            if (utils_1.Utils.isEntity(entity[populate.field])) {
                children.push(entity[populate.field]);
            }
            else if (entity[populate.field] instanceof Reference_1.Reference) {
                children.push(entity[populate.field].unwrap());
            }
            else if (entity[populate.field] instanceof Collection_1.Collection) {
                children.push(...entity[populate.field].getItems());
            }
        }
        const filtered = utils_1.Utils.unique(children);
        const prop = this.metadata.get(entityName).properties[populate.field];
        await this.populate(prop.type, filtered, populate.children, where[prop.name], orderBy[prop.name], refresh, false, false);
    }
    async findChildrenFromPivotTable(filtered, prop, field, refresh, where, orderBy) {
        const map = await this.driver.loadFromPivotTable(prop, filtered.map(e => wrap_1.wrap(e, true).__primaryKeys), where, orderBy, this.em.getTransactionContext());
        const children = [];
        for (const entity of filtered) {
            const items = map[wrap_1.wrap(entity, true).__serializedPrimaryKey].map(item => this.em.merge(prop.type, item, refresh));
            entity[field].hydrate(items);
            children.push(...items);
        }
        return children;
    }
    getChildReferences(entities, prop, refresh) {
        const filtered = this.filterCollections(entities, prop.name, refresh);
        const children = [];
        if (prop.reference === enums_1.ReferenceType.ONE_TO_MANY) {
            children.push(...filtered.map(e => e[prop.name].owner));
        }
        else if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY && prop.owner) {
            children.push(...filtered.reduce((a, b) => [...a, ...b[prop.name].getItems()], []));
        }
        else if (prop.reference === enums_1.ReferenceType.MANY_TO_MANY) { // inversed side
            children.push(...filtered);
        }
        else { // MANY_TO_ONE or ONE_TO_ONE
            children.push(...this.filterReferences(entities, prop.name, refresh));
        }
        return children;
    }
    filterCollections(entities, field, refresh) {
        if (refresh) {
            return entities.filter(e => e[field]);
        }
        return entities.filter(e => utils_1.Utils.isCollection(e[field]) && !e[field].isInitialized(true));
    }
    filterReferences(entities, field, refresh) {
        const children = entities.filter(e => utils_1.Utils.isEntity(e[field], true));
        if (refresh) {
            return children.map(e => utils_1.Utils.unwrapReference(e[field]));
        }
        return children.filter(e => !wrap_1.wrap(e[field], true).isInitialized()).map(e => utils_1.Utils.unwrapReference(e[field]));
    }
    lookupAllRelationships(entityName, prefix = '', visited = []) {
        if (visited.includes(entityName)) {
            return [];
        }
        visited.push(entityName);
        const ret = [];
        const meta = this.metadata.get(entityName);
        Object.values(meta.properties)
            .filter(prop => prop.reference !== enums_1.ReferenceType.SCALAR)
            .forEach(prop => {
            const prefixed = prefix ? `${prefix}.${prop.name}` : prop.name;
            const nested = this.lookupAllRelationships(prop.type, prefixed, visited);
            if (nested.length > 0) {
                ret.push(...nested);
            }
            else {
                ret.push({
                    field: prefixed,
                    strategy: enums_1.LoadStrategy.SELECT_IN,
                });
            }
        });
        return ret;
    }
    lookupEagerLoadedRelationships(entityName, populate, prefix = '', visited = []) {
        if (visited.includes(entityName)) {
            return [];
        }
        visited.push(entityName);
        const meta = this.metadata.get(entityName);
        Object.values(meta.properties)
            .filter(prop => prop.eager)
            .forEach(prop => {
            const prefixed = prefix ? `${prefix}.${prop.name}` : prop.name;
            const nested = this.lookupEagerLoadedRelationships(prop.type, [], prefixed, visited);
            if (nested.length > 0) {
                populate.push(...nested);
            }
            else {
                populate.push({
                    field: prefixed,
                    strategy: enums_1.LoadStrategy.SELECT_IN,
                });
            }
        });
        return populate;
    }
}
exports.EntityLoader = EntityLoader;
//# sourceMappingURL=EntityLoader.js.map