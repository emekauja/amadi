"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataStorage = void 0;
const utils_1 = require("../utils");
const entity_1 = require("../entity");
let MetadataStorage = /** @class */ (() => {
    class MetadataStorage {
        constructor(metadata = {}) {
            this.metadata = utils_1.Utils.copy(metadata);
        }
        static getMetadata(entity, path) {
            const key = entity && path ? entity + '-' + utils_1.Utils.hash(path) : null;
            if (key && !MetadataStorage.metadata[key]) {
                MetadataStorage.metadata[key] = { className: entity, path, properties: {}, hooks: {}, indexes: [], uniques: [] };
            }
            if (key) {
                return MetadataStorage.metadata[key];
            }
            return MetadataStorage.metadata;
        }
        static getMetadataFromDecorator(target) {
            const path = utils_1.Utils.lookupPathFromDecorator();
            const meta = MetadataStorage.getMetadata(target.name, path);
            Object.defineProperty(target, '__path', { value: path, writable: true });
            return meta;
        }
        static init() {
            return new MetadataStorage(MetadataStorage.metadata);
        }
        getAll() {
            return this.metadata;
        }
        get(entity, init = false, validate = true) {
            if (entity && !this.metadata[entity] && validate && !init) {
                throw utils_1.ValidationError.missingMetadata(entity);
            }
            if (!this.metadata[entity] && init) {
                this.metadata[entity] = { properties: {}, hooks: {}, indexes: [], uniques: [] };
            }
            return this.metadata[entity];
        }
        has(entity) {
            return entity in this.metadata;
        }
        set(entity, meta) {
            return this.metadata[entity] = meta;
        }
        reset(entity) {
            delete this.metadata[entity];
        }
        decorate(em) {
            Object.values(this.metadata)
                .filter(meta => meta.prototype && !utils_1.Utils.isEntity(meta.prototype))
                .forEach(meta => entity_1.EntityHelper.decorate(meta, em));
        }
    }
    MetadataStorage.metadata = {};
    return MetadataStorage;
})();
exports.MetadataStorage = MetadataStorage;
//# sourceMappingURL=MetadataStorage.js.map