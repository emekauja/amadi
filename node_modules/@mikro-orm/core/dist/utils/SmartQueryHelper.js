"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartQueryHelper = void 0;
const entity_1 = require("../entity");
const Utils_1 = require("./Utils");
const enums_1 = require("../enums");
let SmartQueryHelper = /** @class */ (() => {
    class SmartQueryHelper {
        static processParams(params, root) {
            if (params instanceof entity_1.Reference) {
                params = params.unwrap();
            }
            if (Utils_1.Utils.isEntity(params)) {
                return SmartQueryHelper.processEntity(params, root);
            }
            if (params === undefined) {
                return null;
            }
            if (Array.isArray(params)) {
                return params.map(item => SmartQueryHelper.processParams(item, true));
            }
            if (Utils_1.Utils.isPlainObject(params)) {
                Object.keys(params).forEach(k => {
                    params[k] = SmartQueryHelper.processParams(params[k], !!k);
                });
            }
            return params;
        }
        static processWhere(where, entityName, meta) {
            where = SmartQueryHelper.processParams(where, true) || {};
            if (Array.isArray(where)) {
                const rootPrimaryKey = meta ? Utils_1.Utils.getPrimaryKeyHash(meta.primaryKeys) : entityName;
                return { [rootPrimaryKey]: { $in: where.map(sub => SmartQueryHelper.processWhere(sub, entityName, meta)) } };
            }
            if (!Utils_1.Utils.isPlainObject(where) || Utils_1.Utils.isPrimaryKey(where)) {
                return where;
            }
            return Object.keys(where).reduce((o, key) => {
                var _a, _b;
                const value = where[key];
                const composite = ((_b = (_a = meta === null || meta === void 0 ? void 0 : meta.properties[key]) === null || _a === void 0 ? void 0 : _a.joinColumns) === null || _b === void 0 ? void 0 : _b.length) > 1;
                if (key in enums_1.GroupOperator) {
                    o[key] = value.map((sub) => SmartQueryHelper.processWhere(sub, entityName, meta));
                    return o;
                }
                if (Array.isArray(value) && !SmartQueryHelper.isSupported(key) && !key.includes('?')) {
                    // comparing single composite key - use $eq instead of $in
                    const op = !value.every(v => Array.isArray(v)) && composite ? '$eq' : '$in';
                    o[key] = { [op]: value };
                    return o;
                }
                if (!SmartQueryHelper.isSupported(key)) {
                    o[key] = where[key];
                }
                else if (key.includes(':')) {
                    const [k, expr] = key.split(':');
                    o[k] = SmartQueryHelper.processExpression(expr, value);
                }
                else {
                    const m = key.match(/([\w-]+) ?([<>=!]+)$/);
                    o[m[1]] = SmartQueryHelper.processExpression(m[2], value);
                }
                return o;
            }, {});
        }
        static processEntity(entity, root) {
            const wrapped = entity_1.wrap(entity, true);
            if (root || wrapped.__meta.compositePK) {
                return wrapped.__primaryKey;
            }
            return Utils_1.Utils.getPrimaryKeyCond(entity, wrapped.__meta.primaryKeys);
        }
        static processExpression(expr, value) {
            switch (expr) {
                case '>': return { $gt: value };
                case '<': return { $lt: value };
                case '>=': return { $gte: value };
                case '<=': return { $lte: value };
                case '!=': return { $ne: value };
                case '!': return { $not: value };
                default: return { ['$' + expr]: value };
            }
        }
        static isSupported(key) {
            return !!SmartQueryHelper.SUPPORTED_OPERATORS.find(op => key.includes(op));
        }
    }
    SmartQueryHelper.SUPPORTED_OPERATORS = ['>', '<', '<=', '>=', '!', '!=', ':in', ':nin', ':gt', ':gte', ':lt', ':lte', ':ne', ':not'];
    return SmartQueryHelper;
})();
exports.SmartQueryHelper = SmartQueryHelper;
//# sourceMappingURL=SmartQueryHelper.js.map