"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CriteriaNode = void 0;
const util_1 = require("util");
const core_1 = require("@mikro-orm/core");
const internal_1 = require("./internal");
/**
 * Helper for working with deeply nested where/orderBy/having criteria. Uses composite pattern to build tree from the payload.
 * Auto-joins relations and converts payload from { books: { publisher: { name: '...' } } } to { 'publisher_alias.name': '...' }
 */
class CriteriaNode {
    constructor(metadata, entityName, parent, key, validate = true) {
        this.metadata = metadata;
        this.entityName = entityName;
        this.parent = parent;
        this.key = key;
        const meta = parent && metadata.get(parent.entityName, false, false);
        if (meta && key) {
            core_1.Utils.splitPrimaryKeys(key).forEach(k => {
                this.prop = Object.values(meta.properties).find(prop => prop.name === k || (prop.fieldNames || []).includes(k));
                if (validate && !this.prop && !k.includes('.') && !core_1.Utils.isOperator(k) && !internal_1.QueryBuilderHelper.isCustomExpression(k)) {
                    throw new Error(`Trying to query by not existing property ${entityName}.${k}`);
                }
            });
        }
    }
    static create(metadata, entityName, payload, parent, key) {
        const customExpression = internal_1.QueryBuilderHelper.isCustomExpression(key || '');
        const scalar = core_1.Utils.isPrimaryKey(payload) || payload instanceof RegExp || payload instanceof Date || customExpression;
        if (Array.isArray(payload) && !scalar) {
            return internal_1.ArrayCriteriaNode.create(metadata, entityName, payload, parent, key);
        }
        if (core_1.Utils.isPlainObject(payload) && !scalar) {
            return internal_1.ObjectCriteriaNode.create(metadata, entityName, payload, parent, key);
        }
        return internal_1.ScalarCriteriaNode.create(metadata, entityName, payload, parent, key);
    }
    process(qb, alias) {
        return this.payload;
    }
    shouldInline(payload) {
        return false;
    }
    willAutoJoin(qb, alias) {
        return false;
    }
    shouldRename(payload) {
        const type = this.prop ? this.prop.reference : null;
        const composite = this.prop && this.prop.joinColumns ? this.prop.joinColumns.length > 1 : false;
        const customExpression = internal_1.QueryBuilderHelper.isCustomExpression(this.key);
        const scalar = core_1.Utils.isPrimaryKey(payload) || payload instanceof RegExp || payload instanceof Date || customExpression;
        const operator = core_1.Utils.isObject(payload) && Object.keys(payload).every(k => core_1.Utils.isOperator(k, false));
        if (composite) {
            return true;
        }
        switch (type) {
            case core_1.ReferenceType.MANY_TO_ONE: return false;
            case core_1.ReferenceType.ONE_TO_ONE: return !this.prop.owner && !(this.parent && this.parent.parent);
            case core_1.ReferenceType.ONE_TO_MANY: return scalar || operator;
            case core_1.ReferenceType.MANY_TO_MANY: return scalar || operator;
            default: return false;
        }
    }
    renameFieldToPK(qb) {
        if (this.prop.reference === core_1.ReferenceType.MANY_TO_MANY) {
            const pivotTable = this.prop.pivotTable;
            const alias = qb.getAliasForEntity(pivotTable, this);
            return core_1.Utils.getPrimaryKeyHash(this.prop.inverseJoinColumns.map(col => `${alias}.${col}`));
        }
        if (this.prop.joinColumns.length > 1) {
            return core_1.Utils.getPrimaryKeyHash(this.prop.joinColumns);
        }
        const meta = this.metadata.get(this.prop.type);
        const alias = qb.getAliasForEntity(meta.name, this);
        const pks = core_1.Utils.flatten(meta.primaryKeys.map(primaryKey => meta.properties[primaryKey].fieldNames));
        return core_1.Utils.getPrimaryKeyHash(pks.map(col => `${alias}.${col}`));
    }
    getPath() {
        let ret = this.parent && this.prop ? this.prop.name : this.entityName;
        if (this.parent instanceof internal_1.ArrayCriteriaNode && this.parent.parent && !this.key) {
            ret = this.parent.parent.key;
        }
        if (this.parent) {
            const parentPath = this.parent.getPath();
            if (parentPath) {
                ret = this.parent.getPath() + '.' + ret;
            }
            else if (this.parent.entityName && ret) {
                ret = this.parent.entityName + '.' + ret;
            }
        }
        return ret;
    }
    [util_1.inspect.custom]() {
        return `${this.constructor.name} ${util_1.inspect({ entityName: this.entityName, key: this.key, payload: this.payload })}`;
    }
}
exports.CriteriaNode = CriteriaNode;
//# sourceMappingURL=CriteriaNode.js.map