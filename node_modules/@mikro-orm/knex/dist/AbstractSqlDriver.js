"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSqlDriver = void 0;
const core_1 = require("@mikro-orm/core");
const index_1 = require("./index");
const SqlEntityManager_1 = require("./SqlEntityManager");
class AbstractSqlDriver extends core_1.DatabaseDriver {
    constructor(config, platform, connection, connector) {
        super(config, connector);
        this.replicas = [];
        this.connection = new connection(this.config);
        this.replicas = this.createReplicas(conf => new connection(this.config, conf, 'read'));
        this.platform = platform;
    }
    getPlatform() {
        return this.platform;
    }
    createEntityManager(useContext) {
        return new SqlEntityManager_1.SqlEntityManager(this.config, this, this.metadata, useContext);
    }
    async find(entityName, where, options, ctx) {
        options = Object.assign({ populate: [], orderBy: {} }, (options || {}));
        const meta = this.metadata.get(entityName);
        const populate = this.autoJoinOneToOneOwner(meta, options.populate);
        const joinedLoads = this.joinedLoads(meta, populate);
        const qb = this.createQueryBuilder(entityName, ctx, !!ctx);
        const fields = this.buildFields(meta, populate, joinedLoads, qb, options.fields);
        qb.select(fields)
            .populate(populate)
            .where(where)
            .orderBy(options.orderBy)
            .groupBy(options.groupBy)
            .having(options.having)
            .withSchema(options.schema);
        if (options.limit !== undefined) {
            qb.limit(options.limit, options.offset);
        }
        core_1.Utils.asArray(options.flags).forEach(flag => qb.setFlag(flag));
        const result = await this.rethrow(qb.execute('all'));
        // if (joinedLoads.length > 0) {
        //   // TODO
        //   return this.processJoinedLoads(result, joinedLoads) as unknown as T;
        // }
        return result;
    }
    async findOne(entityName, where, options, ctx) {
        options = Object.assign({ populate: [], orderBy: {} }, (options || {}));
        const meta = this.metadata.get(entityName);
        const populate = this.autoJoinOneToOneOwner(meta, options.populate);
        const pk = meta.primaryKeys[0];
        if (core_1.Utils.isPrimaryKey(where)) {
            where = { [pk]: where };
        }
        const joinedLoads = this.joinedLoads(meta, populate);
        const qb = this.createQueryBuilder(entityName, ctx, !!ctx);
        const fields = this.buildFields(meta, populate, joinedLoads, qb, options.fields);
        if (joinedLoads.length === 0) {
            qb.limit(1);
        }
        const method = joinedLoads.length > 0 ? 'all' : 'get';
        qb.select(fields)
            .populate(populate)
            .where(where)
            .orderBy(options.orderBy)
            .groupBy(options.groupBy)
            .having(options.having)
            .setLockMode(options.lockMode)
            .withSchema(options.schema);
        core_1.Utils.asArray(options.flags).forEach(flag => qb.setFlag(flag));
        const result = await this.rethrow(qb.execute(method));
        if (Array.isArray(result)) {
            return this.processJoinedLoads(result, joinedLoads);
        }
        return result;
    }
    mapResult(result, meta, populate = [], aliasMap = {}) {
        const ret = super.mapResult(result, meta);
        if (!ret) {
            return null;
        }
        const joinedLoads = this.joinedLoads(meta, populate);
        joinedLoads.forEach(relationName => {
            const relation = meta.properties[relationName];
            const properties = this.metadata.get(relation.type).properties;
            const found = Object.entries(aliasMap).find(([, r]) => r === relation.type);
            const relationAlias = found[0];
            ret[relationName] = ret[relationName] || [];
            const relationPojo = {};
            let relationExists = true;
            Object.values(properties)
                .filter(({ reference }) => reference === core_1.ReferenceType.SCALAR)
                .forEach(prop => {
                const alias = `${relationAlias}_${prop.fieldNames[0]}`;
                const value = ret[alias];
                // If the primary key value for the relation is null, we know we haven't joined to anything
                // and therefore we don't return any record (since all values would be null)
                if (prop.primary && value === null) {
                    relationExists = false;
                }
                if (alias in ret) {
                    relationPojo[prop.name] = ret[alias];
                    delete ret[alias];
                }
            });
            if (relationExists) {
                ret[relationName].push(relationPojo);
            }
        });
        return ret;
    }
    async count(entityName, where, ctx) {
        const pks = this.metadata.get(entityName).primaryKeys;
        const qb = this.createQueryBuilder(entityName, ctx, !!ctx)
            .count(pks, true)
            .where(where);
        const res = await this.rethrow(qb.execute('get', false));
        return +res.count;
    }
    async nativeInsert(entityName, data, ctx) {
        const meta = this.metadata.get(entityName, false, false);
        const collections = this.extractManyToMany(entityName, data);
        const pks = this.getPrimaryKeyFields(entityName);
        const qb = this.createQueryBuilder(entityName, ctx, true);
        const res = await this.rethrow(qb.insert(data).execute('run', false));
        res.row = res.row || {};
        let pk;
        if (pks.length > 1) { // owner has composite pk
            pk = core_1.Utils.getPrimaryKeyCond(data, pks);
        }
        else {
            res.insertId = data[pks[0]] || res.insertId || res.row[pks[0]];
            pk = [res.insertId];
        }
        await this.processManyToMany(meta, pk, collections, false, ctx);
        return res;
    }
    async nativeUpdate(entityName, where, data, ctx) {
        const meta = this.metadata.get(entityName, false, false);
        const pks = this.getPrimaryKeyFields(entityName);
        const collections = this.extractManyToMany(entityName, data);
        let res = { affectedRows: 0, insertId: 0, row: {} };
        if (core_1.Utils.isPrimaryKey(where) && pks.length === 1) {
            where = { [pks[0]]: where };
        }
        if (Object.keys(data).length > 0) {
            const qb = this.createQueryBuilder(entityName, ctx, true)
                .update(data)
                .where(where);
            res = await this.rethrow(qb.execute('run', false));
        }
        const pk = pks.map(pk => core_1.Utils.extractPK(data[pk] || where, meta));
        await this.processManyToMany(meta, pk, collections, true, ctx);
        return res;
    }
    async nativeDelete(entityName, where, ctx) {
        const pks = this.getPrimaryKeyFields(entityName);
        if (core_1.Utils.isPrimaryKey(where) && pks.length === 1) {
            where = { [pks[0]]: where };
        }
        const qb = this.createQueryBuilder(entityName, ctx, true).delete(where);
        return this.rethrow(qb.execute('run', false));
    }
    async syncCollection(coll, ctx) {
        const wrapped = core_1.wrap(coll.owner, true);
        const meta = wrapped.__meta;
        const pks = wrapped.__primaryKeys;
        const snapshot = coll.getSnapshot().map(item => core_1.wrap(item, true).__primaryKeys);
        const current = coll.getItems(false).map(item => core_1.wrap(item, true).__primaryKeys);
        const deleteDiff = snapshot.filter(item => !current.includes(item));
        const insertDiff = current.filter(item => !snapshot.includes(item));
        const target = snapshot.filter(item => current.includes(item)).concat(...insertDiff);
        const equals = core_1.Utils.equals(current, target);
        // wrong order if we just delete and insert to the end
        if (coll.property.fixedOrder && !equals) {
            deleteDiff.length = insertDiff.length = 0;
            deleteDiff.push(...snapshot);
            insertDiff.push(...current);
        }
        await this.rethrow(this.updateCollectionDiff(meta, coll.property, pks, deleteDiff, insertDiff, ctx));
    }
    async loadFromPivotTable(prop, owners, where, orderBy, ctx) {
        const pivotProp2 = this.getPivotInverseProperty(prop);
        const meta = this.metadata.get(prop.type);
        const cond = { [`${prop.pivotTable}.${pivotProp2.name}`]: { $in: meta.compositePK ? owners : owners.map(o => o[0]) } };
        if (!core_1.Utils.isEmpty(where) && Object.keys(where).every(k => core_1.Utils.isOperator(k, false))) {
            where = cond;
        }
        else {
            where = Object.assign(Object.assign({}, where), cond);
        }
        orderBy = this.getPivotOrderBy(prop, orderBy);
        const qb = this.createQueryBuilder(prop.type, ctx, !!ctx);
        const populate = this.autoJoinOneToOneOwner(meta, [{
                field: prop.pivotTable,
            }]);
        qb.select('*').populate(populate).where(where).orderBy(orderBy);
        const items = owners.length ? await this.rethrow(qb.execute('all')) : [];
        const map = {};
        owners.forEach(owner => map['' + core_1.Utils.getPrimaryKeyHash(owner)] = []);
        items.forEach((item) => {
            const key = core_1.Utils.getPrimaryKeyHash(prop.joinColumns.map(col => item[col]));
            map[key].push(item);
            prop.joinColumns.forEach(col => delete item[col]);
            prop.inverseJoinColumns.forEach(col => delete item[col]);
        });
        return map;
    }
    async execute(queryOrKnex, params = [], method = 'all', ctx) {
        return this.rethrow(this.connection.execute(queryOrKnex, params, method, ctx));
    }
    /**
     * 1:1 owner side needs to be marked for population so QB auto-joins the owner id
     */
    autoJoinOneToOneOwner(meta, populate) {
        if (!this.config.get('autoJoinOneToOneOwner')) {
            return populate;
        }
        const relationsToPopulate = populate.map(({ field }) => field);
        const toPopulate = Object.values(meta.properties)
            .filter(prop => prop.reference === core_1.ReferenceType.ONE_TO_ONE && !prop.owner && !relationsToPopulate.includes(prop.name))
            .map(prop => ({ field: prop.name, strategy: prop.strategy }));
        return [...populate, ...toPopulate];
    }
    joinedLoads(meta, populate) {
        return populate
            .filter(({ field, strategy }) => { var _a; return (strategy || ((_a = meta.properties[field]) === null || _a === void 0 ? void 0 : _a.strategy)) === core_1.LoadStrategy.JOINED; })
            .map(({ field }) => field);
    }
    processJoinedLoads(rawResults, joinedLoads) {
        if (rawResults.length === 0) {
            return null;
        }
        return rawResults.reduce((result, value) => {
            joinedLoads.forEach(relationName => {
                const relation = value[relationName];
                const existing = result[relationName] || [];
                result[relationName] = [...existing, ...relation];
            });
            return Object.assign(Object.assign({}, value), result);
        }, {});
    }
    getRefForField(field, schema, alias) {
        return this.connection.getKnex().ref(field).withSchema(schema).as(alias);
    }
    getSelectForJoinedLoad(qb, meta, joinedLoads, populate) {
        const selects = [];
        // alias all fields in the primary table
        Object.values(meta.properties)
            .filter(prop => this.shouldHaveColumn(prop, populate))
            .forEach(prop => selects.push(...prop.fieldNames));
        let previousRelationName;
        joinedLoads.forEach(relationName => {
            previousRelationName = relationName;
            const prop = meta.properties[relationName];
            const meta2 = this.metadata.get(prop.type);
            const properties = Object.values(meta2.properties).filter(prop => {
                var _a;
                /* istanbul ignore next */
                return this.shouldHaveColumn(prop, ((_a = populate.find(p => p.field === relationName)) === null || _a === void 0 ? void 0 : _a.children) || []);
            });
            for (const prop of properties) {
                const tableAlias = qb.getNextAlias(relationName, previousRelationName !== relationName);
                selects.push(...prop.fieldNames.map(fieldName => this.getRefForField(fieldName, tableAlias, `${tableAlias}_${fieldName}`)));
                qb.join(relationName, tableAlias, {}, 'leftJoin');
            }
        });
        return selects;
    }
    createQueryBuilder(entityName, ctx, write) {
        return new index_1.QueryBuilder(entityName, this.metadata, this, ctx, undefined, write ? 'write' : 'read');
    }
    extractManyToMany(entityName, data) {
        if (!this.metadata.has(entityName)) {
            return {};
        }
        const props = this.metadata.get(entityName).properties;
        const ret = {};
        for (const k of Object.keys(data)) {
            const prop = props[k];
            if (prop && prop.reference === core_1.ReferenceType.MANY_TO_MANY) {
                ret[k] = data[k].map((item) => core_1.Utils.asArray(item));
                delete data[k];
            }
        }
        return ret;
    }
    async processManyToMany(meta, pks, collections, clear, ctx) {
        if (!meta) {
            return;
        }
        const props = meta.properties;
        for (const k of Object.keys(collections)) {
            await this.rethrow(this.updateCollectionDiff(meta, props[k], pks, clear, collections[k], ctx));
        }
    }
    async updateCollectionDiff(meta, prop, pks, deleteDiff, insertDiff, ctx) {
        const meta2 = this.metadata.get(prop.type);
        if (!deleteDiff) {
            deleteDiff = [];
        }
        if (deleteDiff === true || deleteDiff.length > 0) {
            const qb1 = this.createQueryBuilder(prop.pivotTable, ctx, true);
            const knex = qb1.getKnex();
            if (Array.isArray(deleteDiff)) {
                knex.whereIn(prop.inverseJoinColumns, deleteDiff);
            }
            meta2.primaryKeys.forEach((pk, idx) => knex.andWhere(prop.joinColumns[idx], pks[idx]));
            await this.execute(knex.delete());
        }
        const items = insertDiff.map(item => {
            const cond = {};
            prop.joinColumns.forEach((joinColumn, idx) => cond[joinColumn] = pks[idx]);
            prop.inverseJoinColumns.forEach((inverseJoinColumn, idx) => cond[inverseJoinColumn] = item[idx]);
            return cond;
        });
        if (this.platform.allowsMultiInsert()) {
            const qb2 = this.createQueryBuilder(prop.pivotTable, ctx, true);
            await this.execute(qb2.getKnex().insert(items));
        }
        else {
            await core_1.Utils.runSerial(items, item => this.createQueryBuilder(prop.pivotTable, ctx, true).insert(item).execute('run', false));
        }
    }
    async lockPessimistic(entity, mode, ctx) {
        const qb = this.createQueryBuilder(entity.constructor.name, ctx);
        const meta = core_1.wrap(entity, true).__meta;
        const cond = core_1.Utils.getPrimaryKeyCond(entity, meta.primaryKeys);
        qb.select('1').where(cond).setLockMode(mode);
        await this.rethrow(qb.execute());
    }
    buildFields(meta, populate, joinedLoads, qb, fields) {
        const props = Object.values(meta.properties).filter(prop => this.shouldHaveColumn(prop, populate));
        const lazyProps = Object.values(meta.properties).filter(prop => prop.lazy && !populate.some(p => p.field === prop.name || p.all));
        const hasExplicitFields = !!fields;
        if (fields) {
            fields.unshift(...meta.primaryKeys.filter(pk => !fields.includes(pk)));
        }
        else if (joinedLoads.length > 0) {
            fields = this.getSelectForJoinedLoad(qb, meta, joinedLoads, populate);
        }
        else if (lazyProps.length > 0) {
            fields = core_1.Utils.flatten(props.filter(p => !lazyProps.includes(p)).map(p => p.fieldNames));
        }
        if (fields && !hasExplicitFields) {
            // TODO joined loads will need different aliasing here, this works only for the root entity
            Object.values(meta.properties)
                .filter(prop => prop.formula)
                .forEach(prop => {
                const alias = qb.ref(qb.alias).toString();
                const aliased = qb.ref(prop.fieldNames[0]).toString();
                fields.push(`${prop.formula(alias)} as ${aliased}`);
            });
        }
        return fields || ['*'];
    }
}
exports.AbstractSqlDriver = AbstractSqlDriver;
//# sourceMappingURL=AbstractSqlDriver.js.map